// ========================================
// DONULAND MANAGEMENT SYSTEM - MAIN.JS
// Kompletn√≠ predikƒçn√≠ syst√©m s AI algoritmy
// ========================================

console.log('üç© Donuland Management System se inicializuje...');

// ===== GLOB√ÅLN√ç KONFIGURACE =====
const CONFIG = {
    GOOGLE_SHEETS_URL: 'https://docs.google.com/spreadsheets/d/1LclCz9hb0hlb1D92OyVqk6Cbam7PRK6KgAzGgiGs6iE/edit?usp=sharing',
    WEATHER_API_KEY: 'c2fb0e86623880dc86162892b0fd9c95',
    MAPS_API_KEY: 'AIzaSyBTTA_MKa6FrxKpkcd7c5-d3FnC6FBLVTc',
    BASE_CITY: 'Praha',
    
    // Business parametry
    DONUT_COST: 32,
    DONUT_PRICE: 50,
    FRANCHISE_PRICE: 52,
    HOURLY_WAGE: 150,
    WORK_HOURS: 10,
    
    // Konverzn√≠ faktory podle typu akce
    CONVERSION_RATES: {
        'festival': 0.15,
        'food': 0.18,
        'chocolate': 0.25,
        'family': 0.16,
        'cultural': 0.12,
        'sports': 0.08,
        'fair': 0.10,
        'other': 0.10
    }
};

// ===== GLOB√ÅLN√ç PROMƒöNN√â =====
let historicalData = [];
let isLoading = false;
let weatherCache = new Map();
let distanceCache = new Map();

// ===== INICIALIZACE APLIKACE =====
document.addEventListener('DOMContentLoaded', function() {
    console.log('üì± DOM naƒçten, spou≈°t√≠m inicializaci...');
    
    setTimeout(() => {
        initializeApp();
    }, 100);
});

async function initializeApp() {
    console.log('üöÄ Inicializuji aplikaci...');
    
    try {
        // Nastaven√≠ v√Ωchoz√≠ch hodnot
        setDefaultValues();
        
        // Naƒçten√≠ ulo≈æen√Ωch nastaven√≠
        loadSettings();
        
        // Skryt√≠ loading screen
        setTimeout(() => {
            document.getElementById('loadingScreen').style.display = 'none';
            document.getElementById('mainApp').style.display = 'block';
            showNotification('üç© Donuland Management System p≈ôipraven!', 'success');
        }, 3000);
        
        // Automatick√© naƒçten√≠ dat
        setTimeout(() => {
            loadGoogleSheetsData();
        }, 4000);
        
        console.log('‚úÖ Aplikace √∫spƒõ≈°nƒõ inicializov√°na');
        
    } catch (error) {
        console.error('‚ùå Chyba p≈ôi inicializaci:', error);
        showNotification('Chyba p≈ôi inicializaci: ' + error.message, 'error');
    }
}

// ===== NAVIGACE =====
function showSection(sectionId) {
    console.log('üìã Zobrazuji sekci:', sectionId);
    
    // Skryt√≠ v≈°ech sekc√≠
    document.querySelectorAll('.section').forEach(section => {
        section.classList.remove('active');
    });
    
    // Zobrazen√≠ c√≠lov√© sekce
    const targetSection = document.getElementById(sectionId);
    if (targetSection) {
        targetSection.classList.add('active');
    }
    
    // Aktivn√≠ stav navigace
    document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.remove('active');
    });
    
    event.target.closest('.nav-item').classList.add('active');
    
    // Naƒçten√≠ dat pro konkr√©tn√≠ sekci
    if (sectionId === 'analysis') {
        loadAnalysisData();
    }
}

// ===== GOOGLE SHEETS DATA MANAGER =====
async function loadGoogleSheetsData() {
    if (isLoading) {
        console.log('‚è≥ Naƒç√≠t√°n√≠ ji≈æ prob√≠h√°...');
        return;
    }
    
    isLoading = true;
    showNotification('üîÑ Naƒç√≠t√°m data z Google Sheets...', 'info');
    
    try {
        const sheetUrl = document.getElementById('googleSheetsUrl').value;
        const sheetId = extractSheetId(sheetUrl);
        
        if (!sheetId) {
            throw new Error('Neplatn√© Google Sheets URL');
        }
        
        const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;
        console.log('üåê Naƒç√≠t√°m z:', csvUrl);
        
        const response = await fetch(csvUrl);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const csvText = await response.text();
        if (!csvText || csvText.trim().length === 0) {
            throw new Error('Pr√°zdn√Ω response z Google Sheets');
        }
        
        historicalData = parseCSV(csvText);
        console.log(`‚úÖ Naƒçteno ${historicalData.length} z√°znam≈Ø`);
        
        showNotification(`‚úÖ √öspƒõ≈°nƒõ naƒçteno ${historicalData.length} z√°znam≈Ø z Google Sheets!`, 'success');
        
        // Aktualizace status indik√°toru
        updateStatusIndicator('success', `${historicalData.length} z√°znam≈Ø`);
        
        // Refresh anal√Ωzy pokud je aktivn√≠
        if (document.getElementById('analysis').classList.contains('active')) {
            loadAnalysisData();
        }
        
    } catch (error) {
        console.error('‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ Google Sheets:', error);
        showNotification(`‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ dat: ${error.message}`, 'error');
        updateStatusIndicator('error', 'Chyba naƒç√≠t√°n√≠');
    } finally {
        isLoading = false;
    }
}

function extractSheetId(url) {
    const patterns = [
        /\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/,
        /spreadsheets\/d\/([a-zA-Z0-9-_]+)/
    ];
    
    for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match) return match[1];
    }
    return null;
}

function parseCSV(csvText) {
    const lines = csvText.split('\n').filter(line => line.trim());
    if (lines.length < 2) {
        throw new Error('CSV mus√≠ obsahovat alespo≈à hlaviƒçku a jeden ≈ô√°dek');
    }
    
    const headers = parseCSVLine(lines[0]);
    const data = [];
    
    for (let i = 1; i < lines.length; i++) {
        try {
            const values = parseCSVLine(lines[i]);
            const row = {};
            
            headers.forEach((header, index) => {
                row[header.trim()] = (values[index] || '').trim();
            });
            
            // Filtrovat pouze ≈ô√°dky s daty
            if (Object.values(row).some(value => value && value.length > 0)) {
                data.push(row);
            }
        } catch (error) {
            console.warn(`‚ö†Ô∏è Chyba p≈ôi parsov√°n√≠ ≈ô√°dku ${i + 1}:`, error);
        }
    }
    
    return data;
}

function parseCSVLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
        const char = line[i];
        
        if (char === '"') {
            inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
            result.push(current.trim());
            current = '';
        } else {
            current += char;
        }
    }
    
    result.push(current.trim());
    return result;
}

// ===== VZD√ÅLENOST A GOOGLE MAPS =====
async function updateDistance() {
    const city = document.getElementById('eventCity').value.trim();
    const distanceInput = document.getElementById('distance');
    
    if (!city) {
        distanceInput.value = '';
        return;
    }
    
    // Kontrola cache
    if (distanceCache.has(city)) {
        distanceInput.value = distanceCache.get(city);
        return;
    }
    
    try {
        distanceInput.value = 'Poƒç√≠t√°m...';
        
        const apiKey = document.getElementById('mapsApiKey').value;
        if (!apiKey) {
            throw new Error('Google Maps API kl√≠ƒç nen√≠ nastaven');
        }
        
        const response = await fetch(
            `https://maps.googleapis.com/maps/api/distancematrix/json?origins=${encodeURIComponent(CONFIG.BASE_CITY)}&destinations=${encodeURIComponent(city)}&key=${apiKey}&mode=driving`
        );
        
        if (!response.ok) {
            throw new Error('Chyba Google Maps API');
        }
        
        const data = await response.json();
        
        if (data.status === 'OK' && data.rows[0].elements[0].status === 'OK') {
            const distanceKm = Math.round(data.rows[0].elements[0].distance.value / 1000);
            distanceCache.set(city, distanceKm);
            distanceInput.value = distanceKm;
            console.log(`üìç Vzd√°lenost Praha ‚Üí ${city}: ${distanceKm} km`);
        } else {
            throw new Error('Mƒõsto nenalezeno');
        }
        
    } catch (error) {
        console.error('‚ùå Chyba p≈ôi v√Ωpoƒçtu vzd√°lenosti:', error);
        
        // Fallback - odhad podle zn√°m√Ωch mƒõst
        const estimatedDistance = estimateDistance(city);
        distanceInput.value = estimatedDistance;
        distanceCache.set(city, estimatedDistance);
        
        if (estimatedDistance === 0) {
            showNotification(`‚ö†Ô∏è Nepoda≈ôilo se vypoƒç√≠tat vzd√°lenost k mƒõstu "${city}"`, 'warning');
        }
    }
}

function estimateDistance(city) {
    const distances = {
        'brno': 200,
        'ostrava': 350,
        'plzen': 90,
        'plze≈à': 90,
        'liberec': 110,
        'olomouc': 280,
        'budejovice': 150,
        'ƒçesk√© budƒõjovice': 150,
        'hradec kralove': 120,
        'hradec kr√°lov√©': 120,
        'usti nad labem': 80,
        '√∫st√≠ nad labem': 80,
        'pardubice': 110,
        'zlin': 320,
        'zl√≠n': 320,
        'hav√≠≈ôov': 380,
        'kladno': 30,
        'most': 80,
        'karvin√°': 380,
        'opava': 350,
        'fr√Ωdek-m√≠stek': 360,
        'dƒõƒç√≠n': 100,
        'teplice': 85,
        'chomutov': 100,
        'jihlava': 130,
        'mlad√° boleslav': 60,
        'prostƒõjov': 250,
        'p≈ôerov': 270,
        'jablonec nad nisou': 120,
        't≈ôeb√≠ƒç': 170,
        'karlovy vary': 130,
        'ƒçesk√° l√≠pa': 80,
        't≈ôinec': 380,
        't√°bor': 90,
        'kol√≠n': 60,
        'p≈ô√≠bram': 70,
        'cheb': 170,
        'trutnov': 160
    };
    
    const cityLower = city.toLowerCase();
    for (const [knownCity, distance] of Object.entries(distances)) {
        if (cityLower.includes(knownCity) || knownCity.includes(cityLower)) {
            return distance;
        }
    }
    
    return 0; // Nezn√°m√© mƒõsto
}

// ===== POƒåAS√ç =====
async function updateWeather() {
    const city = document.getElementById('eventCity').value.trim();
    const date = document.getElementById('eventDate').value;
    const weatherDisplay = document.getElementById('weatherDisplay');
    
    if (!city || !date) {
        weatherDisplay.innerHTML = '<p>üìç Vyberte mƒõsto a datum pro naƒçten√≠ p≈ôedpovƒõdi poƒças√≠</p>';
        return;
    }
    
    const cacheKey = `${city}-${date}`;
    if (weatherCache.has(cacheKey)) {
        displayWeather(weatherCache.get(cacheKey));
        return;
    }
    
    try {
        weatherDisplay.innerHTML = '<div class="loading-inline"><div class="spinner"></div><span>Naƒç√≠t√°m poƒças√≠...</span></div>';
        
        const apiKey = document.getElementById('weatherApiKey').value;
        if (!apiKey) {
            throw new Error('Weather API kl√≠ƒç nen√≠ nastaven');
        }
        
        // Z√≠sk√°n√≠ sou≈ôadnic mƒõsta
        const geoResponse = await fetch(
            `https://api.openweathermap.org/geo/1.0/direct?q=${encodeURIComponent(city)}&limit=1&appid=${apiKey}`
        );
        
        if (!geoResponse.ok) {
            throw new Error('Chyba p≈ôi hled√°n√≠ mƒõsta');
        }
        
        const geoData = await geoResponse.json();
        if (geoData.length === 0) {
            throw new Error('Mƒõsto nenalezeno');
        }
        
        const { lat, lon } = geoData[0];
        
        // Kontrola, zda je datum v budoucnosti
        const targetDate = new Date(date);
        const today = new Date();
        const daysDiff = Math.ceil((targetDate - today) / (1000 * 60 * 60 * 24));
        
        let weatherData;
        
        if (daysDiff <= 0) {
            // Aktu√°ln√≠ poƒças√≠
            const response = await fetch(
                `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric&lang=cs`
            );
            const data = await response.json();
            weatherData = {
                temp: Math.round(data.main.temp),
                description: data.weather[0].description,
                main: data.weather[0].main,
                humidity: data.main.humidity,
                windSpeed: data.wind?.speed || 0
            };
        } else if (daysDiff <= 5) {
            // 5denn√≠ p≈ôedpovƒõƒè
            const response = await fetch(
                `https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric&lang=cs`
            );
            const data = await response.json();
            
            // Najdeme nejbli≈æ≈°√≠ p≈ôedpovƒõƒè k c√≠lov√©mu datu
            const targetTime = targetDate.getTime();
            let closestForecast = data.list[0];
            let minDiff = Math.abs(new Date(closestForecast.dt * 1000) - targetTime);
            
            for (const forecast of data.list) {
                const forecastTime = new Date(forecast.dt * 1000);
                const diff = Math.abs(forecastTime - targetTime);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestForecast = forecast;
                }
            }
            
            weatherData = {
                temp: Math.round(closestForecast.main.temp),
                description: closestForecast.weather[0].description,
                main: closestForecast.weather[0].main,
                humidity: closestForecast.main.humidity,
                windSpeed: closestForecast.wind?.speed || 0
            };
        } else {
            // Pro vzd√°lenƒõj≈°√≠ data pou≈æ√≠v√°me aktu√°ln√≠ poƒças√≠ jako odhad
            const response = await fetch(
                `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric&lang=cs`
            );
            const data = await response.json();
            weatherData = {
                temp: Math.round(data.main.temp),
                description: data.weather[0].description + ' (odhad)',
                main: data.weather[0].main,
                humidity: data.main.humidity,
                windSpeed: data.wind?.speed || 0
            };
        }
        
        weatherCache.set(cacheKey, weatherData);
        displayWeather(weatherData);
        console.log(`üå§Ô∏è Poƒças√≠ naƒçteno pro ${city}:`, weatherData);
        
    } catch (error) {
        console.error('‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ poƒças√≠:', error);
        weatherDisplay.innerHTML = `<p class="error">‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ poƒças√≠: ${error.message}</p>`;
    }
}

function displayWeather(weather) {
    const weatherDisplay = document.getElementById('weatherDisplay');
    const icon = getWeatherIcon(weather.main);
    const warnings = getWeatherWarnings(weather);
    
    const warningsHtml = warnings.length > 0 ? `
        <div style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 6px; border-left: 4px solid #ffc107;">
            <strong>‚ö†Ô∏è Varov√°n√≠:</strong> ${warnings.join(', ')}
        </div>
    ` : '';
    
    weatherDisplay.innerHTML = `
        <div class="weather-card">
            <div class="weather-icon">${icon}</div>
            <h4>${weather.description}</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 15px; margin-top: 15px;">
                <div>
                    <div style="font-size: 1.5em; font-weight: bold;">${weather.temp}¬∞C</div>
                    <div style="opacity: 0.8;">Teplota</div>
                </div>
                <div>
                    <div style="font-size: 1.5em; font-weight: bold;">${weather.humidity}%</div>
                    <div style="opacity: 0.8;">Vlhkost</div>
                </div>
                <div>
                    <div style="font-size: 1.5em; font-weight: bold;">${Math.round(weather.windSpeed)} m/s</div>
                    <div style="opacity: 0.8;">V√≠tr</div>
                </div>
            </div>
            ${warningsHtml}
        </div>
    `;
}

function getWeatherIcon(main) {
    const icons = {
        'Clear': '‚òÄÔ∏è',
        'Clouds': '‚òÅÔ∏è',
        'Rain': 'üåßÔ∏è',
        'Snow': '‚ùÑÔ∏è',
        'Thunderstorm': '‚õàÔ∏è',
        'Drizzle': 'üå¶Ô∏è',
        'Mist': 'üå´Ô∏è',
        'Fog': 'üå´Ô∏è'
    };
    return icons[main] || 'üå§Ô∏è';
}

function getWeatherWarnings(weather) {
    const warnings = [];
    
    if (weather.temp > 25) {
        warnings.push('Vysok√© teploty - riziko rozt√©k√°n√≠ ƒçokol√°dov√Ωch polev');
    }
    if (weather.temp < 5) {
        warnings.push('N√≠zk√© teploty - oƒçek√°vejte ni≈æ≈°√≠ n√°v≈°tƒõvnost');
    }
    if (weather.main === 'Rain' || weather.main === 'Drizzle') {
        warnings.push('D√©≈°≈• - v√Ωznamnƒõ sn√≠≈æ√≠ n√°v≈°tƒõvnost');
    }
    if (weather.windSpeed > 10) {
        warnings.push('Siln√Ω v√≠tr - zajistƒõte pevn√© kotven√≠ st√°nku');
    }
    
    return warnings;
}

// ===== BUSINESS MODEL =====
function updateBusinessModelInfo() {
    const model = document.getElementById('businessModel').value;
    const infoDiv = document.getElementById('businessModelInfo');
    
    if (!model) {
        infoDiv.style.display = 'none';
        return;
    }
    
    const models = {
        'owner': {
            description: 'üè™ <strong>Majitel:</strong> Vy + 2 brig√°dn√≠ci',
            details: 'N√°klady na mzdy: 2 √ó 150 Kƒç/h √ó 10h = 3000 Kƒç',
            profit: '100% zisku po odeƒçten√≠ v≈°ech n√°klad≈Ø'
        },
        'employee': {
            description: 'üë®‚Äçüíº <strong>Zamƒõstnanec:</strong> Vy + 1 brig√°dn√≠k + 5% z obratu',
            details: 'N√°klady: Va≈°e mzda (150 Kƒç/h √ó 10h) + brig√°dn√≠k (150 Kƒç/h √ó 10h) + 5% z obratu',
            profit: 'Fixn√≠ mzda bez √∫ƒçasti na zisku'
        },
        'franchise': {
            description: 'ü§ù <strong>Fran≈°√≠zant:</strong> N√°kup donut≈Ø za 52 Kƒç/ks',
            details: 'V√°≈° zisk: 20 Kƒç na donut (52 - 32 Kƒç n√°klad)',
            profit: 'Fran≈°√≠zant hrad√≠ n√°jem a mzdy'
        }
    };
    
    const modelInfo = models[model];
    infoDiv.innerHTML = `
        <div style="padding: 15px;">
            <div>${modelInfo.description}</div>
            <div style="margin: 8px 0; font-size: 0.9em; color: #666;">${modelInfo.details}</div>
            <div style="font-size: 0.9em; color: #28a745;"><strong>${modelInfo.profit}</strong></div>
        </div>
    `;
    infoDiv.style.display = 'block';
}

function updateRentInputs() {
    const rentType = document.getElementById('rentType').value;
    
    // Skryt√≠ v≈°ech skupin
    ['fixedRentGroup', 'percentageRentGroup', 'mixedFixedGroup', 'mixedPercentageGroup'].forEach(id => {
        const element = document.getElementById(id);
        if (element) element.style.display = 'none';
    });
    
    // Zobrazen√≠ relevantn√≠ch skupin
    switch(rentType) {
        case 'fixed':
            document.getElementById('fixedRentGroup').style.display = 'block';
            break;
        case 'percentage':
            document.getElementById('percentageRentGroup').style.display = 'block';
            break;
        case 'mixed':
            document.getElementById('mixedFixedGroup').style.display = 'block';
            document.getElementById('mixedPercentageGroup').style.display = 'block';
            break;
    }
}

// ===== AI PREDIKƒåN√ç ENGINE =====
async function updatePrediction() {
    console.log('ü§ñ Aktualizuji predikci...');
    
    const eventData = gatherEventData();
    if (!isEventDataComplete(eventData)) {
        document.getElementById('predictionResults').innerHTML = '<p>üìã Vypl≈àte v≈°echny √∫daje pro zobrazen√≠ predikce</p>';
        return;
    }
    
    try {
        // AI predikce podle historick√Ωch dat
        const prediction = await calculateAIPrediction(eventData);
        
        // Business v√Ωpoƒçty
        const businessResults = calculateBusinessMetrics(eventData, prediction);
        
        // Zobrazen√≠ v√Ωsledk≈Ø
        displayPredictionResults(prediction, businessResults, eventData);
        
    } catch (error) {
        console.error('‚ùå Chyba p≈ôi v√Ωpoƒçtu predikce:', error);
        showNotification('Chyba p≈ôi v√Ωpoƒçtu predikce: ' + error.message, 'error');
    }
}

function gatherEventData() {
    return {
        name: document.getElementById('eventName').value.trim(),
        city: document.getElementById('eventCity').value.trim(),
        date: document.getElementById('eventDate').value,
        expectedVisitors: parseInt(document.getElementById('expectedVisitors').value) || 0,
        competition: parseInt(document.getElementById('competition').value) || 2,
        businessModel: document.getElementById('businessModel').value,
        rentType: document.getElementById('rentType').value,
        fixedRent: parseFloat(document.getElementById('fixedRent').value) || 0,
        percentageRent: parseFloat(document.getElementById('percentageRent').value) || 0,
        mixedFixed: parseFloat(document.getElementById('mixedFixed').value) || 0,
        mixedPercentage: parseFloat(document.getElementById('mixedPercentage').value) || 0,
        distance: parseFloat(document.getElementById('distance').value) || 0
    };
}

function isEventDataComplete(data) {
    return data.name && data.city && data.date && data.expectedVisitors > 0 && data.businessModel;
}

async function calculateAIPrediction(eventData) {
    console.log('üß† Spou≈°t√≠m AI predikƒçn√≠ algoritmus...');
    
    // Z√°kladn√≠ konverzn√≠ pomƒõr
    let baseConversion = 0.12; // 12% z√°kladn√≠ konverze
    
    // Faktor podle historick√Ωch dat
    const historicalFactor = calculateHistoricalFactor(eventData);
    
    // Faktor podle poƒças√≠
    const weatherFactor = await calculateWeatherFactor(eventData);
    
    // Faktor podle konkurence
    const competitionFactor = calculateCompetitionFactor(eventData.competition);
    
    // Faktor podle velikosti mƒõsta
    const cityFactor = calculateCityFactor(eventData.city);
    
    // Faktor podle typu akce (z n√°zvu)
    const eventTypeFactor = calculateEventTypeFactor(eventData.name);
    
    // Fin√°ln√≠ predikce
    const finalConversion = baseConversion * historicalFactor * weatherFactor * competitionFactor * cityFactor * eventTypeFactor;
    const predictedSales = Math.round(eventData.expectedVisitors * finalConversion);
    
    console.log('üìä Predikƒçn√≠ faktory:', {
        base: baseConversion,
        historical: historicalFactor,
        weather: weatherFactor,
        competition: competitionFactor,
        city: cityFactor,
        eventType: eventTypeFactor,
        final: finalConversion
    });
    
    return {
        predictedSales: Math.max(predictedSales, 50), // Minim√°lnƒõ 50 donut≈Ø
        confidence: calculateConfidence(eventData, historicalFactor),
        factors: {
            historical: historicalFactor,
            weather: weatherFactor,
            competition: competitionFactor,
            city: cityFactor,
            eventType: eventTypeFactor
        }
    };
}

function calculateHistoricalFactor(eventData) {
    if (historicalData.length === 0) {
        return 1.0; // Neutr√°ln√≠ pokud nejsou data
    }
    
    // Hled√°me podobn√© akce
    const similarEvents = historicalData.filter(row => {
        const rowCity = (row['Mƒõsto'] || row['Lokace'] || '').toLowerCase();
        const eventCity = eventData.city.toLowerCase();
        
        // Podobn√© mƒõsto nebo n√°zev akce
        return rowCity.includes(eventCity) || eventCity.includes(rowCity) ||
               (row['N√°zev akce'] || '').toLowerCase().includes(eventData.name.toLowerCase());
    });
    
    if (similarEvents.length === 0) {
        // Pou≈æijeme pr≈Ømƒõr ze v≈°ech akc√≠
        const avgSales = historicalData.reduce((sum, row) => {
            const sales = parseFloat(row['Skuteƒçn√Ω prodej'] || row['N'] || 0);
            const visitors = parseFloat(row['N√°v≈°tƒõvnost'] || 0);
            return sum + (visitors > 0 ? sales / visitors : 0);
        }, 0) / Math.max(historicalData.length, 1);
        
        return Math.max(avgSales / 0.12, 0.5); // Relativnƒõ k z√°kladn√≠ konverzi
    }
    
    // Pr≈Ømƒõr z podobn√Ωch akc√≠
    const avgConversion = similarEvents.reduce((sum, row) => {
        const sales = parseFloat(row['Skuteƒçn√Ω prodej'] || row['N'] || 0);
        const visitors = parseFloat(row['N√°v≈°tƒõvnost'] || 0);
        const rating = parseFloat(row['Hodnocen√≠'] || row['X'] || 3);
        
        let conversion = visitors > 0 ? sales / visitors : 0;
        conversion *= (rating / 3); // √öprava podle hodnocen√≠ (3 = pr≈Ømƒõr)
        
        return sum + conversion;
    }, 0) / similarEvents.length;
    
    const factor = Math.max(avgConversion / 0.12, 0.3);
    console.log(`üìà Historical faktor: ${factor.toFixed(2)} (ze ${similarEvents.length} podobn√Ωch akc√≠)`);
    
    return Math.min(factor, 3.0); // Maxim√°lnƒõ 3x
}

async function calculateWeatherFactor(eventData) {
    const cacheKey = `${eventData.city}-${eventData.date}`;
    const weather = weatherCache.get(cacheKey);
    
    if (!weather) {
        return 1.0; // Neutr√°ln√≠ pokud nen√≠ poƒças√≠
    }
    
    let factor = 1.0;
    
    // Teplota
    if (weather.temp >= 18 && weather.temp <= 25) {
        factor *= 1.1; // Ide√°ln√≠ teplota
    } else if (weather.temp > 25) {
        factor *= 0.8; // Horko - donuts se taj√≠
    } else if (weather.temp < 10) {
        factor *= 0.7; // Zima - m√©nƒõ lid√≠ venku
    }
    
    // Sr√°≈æky
    if (weather.main === 'Rain' || weather.main === 'Drizzle') {
        factor *= 0.5; // D√©≈°≈• v√Ωraznƒõ sni≈æuje n√°v≈°tƒõvnost
    } else if (weather.main === 'Clear') {
        factor *= 1.15; // Slunce zvy≈°uje n√°v≈°tƒõvnost
    }
    
    // V√≠tr
    if (weather.windSpeed > 10) {
        factor *= 0.9; // Siln√Ω v√≠tr
    }
    
    console.log(`üå§Ô∏è Weather faktor: ${factor.toFixed(2)} (${weather.description})`);
    return Math.max(factor, 0.3);
}

function calculateCompetitionFactor(competition) {
    const factors = {
        1: 1.2,  // Mal√° konkurence
        2: 1.0,  // St≈ôedn√≠ konkurence
        3: 0.8   // Velk√° konkurence
    };
    
    return factors[competition] || 1.0;
}

function calculateCityFactor(city) {
    // Odhad podle velikosti mƒõsta
    const cityPopulations = {
        'praha': 1.3,
        'brno': 1.2,
        'ostrava': 1.1,
        'plze≈à': 1.05,
        'liberec': 1.0,
        'olomouc': 1.0
    };
    
    const cityLower = city.toLowerCase();
    for (const [knownCity, factor] of Object.entries(cityPopulations)) {
        if (cityLower.includes(knownCity)) {
            return factor;
        }
    }
    
    return 1.0; // Standardn√≠ mƒõsto
}

function calculateEventTypeFactor(eventName) {
    const nameLower = eventName.toLowerCase();
    
    if (nameLower.includes('ƒçokol√°d') || nameLower.includes('chocolate')) {
        return 1.8; // ƒåokol√°dov√© festivaly jsou velmi √∫spƒõ≈°n√©
    }
    if (nameLower.includes('food') || nameLower.includes('gastro')) {
        return 1.5;
    }
    if (nameLower.includes('rodin') || nameLower.includes('family')) {
        return 1.4;
    }
    if (nameLower.includes('festival')) {
        return 1.3;
    }
    if (nameLower.includes('trh') || nameLower.includes('market')) {
        return 1.2;
    }
    if (nameLower.includes('sport')) {
        return 0.8;
    }
    
    return 1.0; // Standardn√≠ akce
}

function calculateConfidence(eventData, historicalFactor) {
    let confidence = 60; // Z√°kladn√≠ spolehlivost
    
    // Zv√Ω≈°en√≠ podle historick√Ωch dat
    if (historicalData.length > 10) {
        confidence += 15;
    } else if (historicalData.length > 5) {
        confidence += 10;
    }
    
    // Zv√Ω≈°en√≠ pokud m√°me historick√° data pro mƒõsto
    const cityEvents = historicalData.filter(row => 
        (row['Mƒõsto'] || row['Lokace'] || '').toLowerCase().includes(eventData.city.toLowerCase())
    );
    
    if (cityEvents.length > 0) {
        confidence += 10;
    }
    
    // Sn√≠≈æen√≠ pro nestandartn√≠ p≈ô√≠pady
    if (eventData.expectedVisitors > 5000) {
        confidence -= 10;
    }
    if (eventData.expectedVisitors < 100) {
        confidence -= 15;
    }
    
    return Math.max(Math.min(confidence, 95), 30);
}

function calculateBusinessMetrics(eventData, prediction) {
    const donutPrice = parseFloat(document.getElementById('donutPrice').value) || CONFIG.DONUT_PRICE;
    const donutCost = parseFloat(document.getElementById('donutCost').value) || CONFIG.DONUT_COST;
    
    // Z√°kladn√≠ v√Ωpoƒçty
    const revenue = prediction.predictedSales * donutPrice;
    const productionCosts = prediction.predictedSales * donutCost;
    
    // Doprava (Praha tam a zpƒõt)
    const fuelCostPerKm = 8; // Kƒç/km
    const transportCosts = eventData.distance * 2 * fuelCostPerKm;
    
    // Mzdy podle business modelu
    let laborCosts = 0;
    let revenueShare = 0;
    let franchiseProfit = 0;
    
    switch(eventData.businessModel) {
        case 'owner':
            laborCosts = 2 * CONFIG.HOURLY_WAGE * CONFIG.WORK_HOURS; // 2 brig√°dn√≠ci
            break;
        case 'employee':
            laborCosts = CONFIG.HOURLY_WAGE * CONFIG.WORK_HOURS; // Va≈°e mzda
            laborCosts += CONFIG.HOURLY_WAGE * CONFIG.WORK_HOURS; // 1 brig√°dn√≠k
            revenueShare = revenue * 0.05; // 5% z obratu
            break;
        case 'franchise':
            franchiseProfit = prediction.predictedSales * (CONFIG.FRANCHISE_PRICE - CONFIG.DONUT_COST);
            break;
    }
    
    // N√°jem
    let rentCosts = 0;
    switch(eventData.rentType) {
        case 'fixed':
            rentCosts = eventData.fixedRent;
            break;
        case 'percentage':
            rentCosts = revenue * (eventData.percentageRent / 100);
            break;
        case 'mixed':
            rentCosts = eventData.mixedFixed + (revenue * (eventData.mixedPercentage / 100));
            break;
    }
    
    // Celkov√© n√°klady
    const totalCosts = productionCosts + transportCosts + laborCosts + revenueShare + rentCosts;
    
    // Zisk
    let profit;
    if (eventData.businessModel === 'franchise') {
        profit = franchiseProfit; // V√°≈° zisk z fran≈°√≠zy
    } else {
        profit = revenue - totalCosts;
    }
    
    const profitMargin = revenue > 0 ? (profit / revenue) * 100 : 0;
    
    return {
        revenue,
        costs: {
            production: productionCosts,
            transport: transportCosts,
            labor: laborCosts,
            revenueShare,
            rent: rentCosts,
            total: totalCosts
        },
        profit,
        profitMargin,
        franchiseProfit
    };
}

function displayPredictionResults(prediction, businessResults, eventData) {
    const resultsDiv = document.getElementById('predictionResults');
    
    const isProfit = businessResults.profit > 0;
    const profitClass = isProfit ? 'positive' : 'negative';
    
    // Breakdown n√°klad≈Ø
    const costsBreakdown = eventData.businessModel === 'franchise' ? `
        <div class="cost-item">
            <span>üè™ V√°≈° zisk z fran≈°√≠zy:</span>
            <span><strong>${businessResults.franchiseProfit.toLocaleString()} Kƒç</strong></span>
        </div>
        <div class="cost-item">
            <span>üì¶ Prodej donut≈Ø fran≈°√≠zantovi (${prediction.predictedSales} √ó 52 Kƒç):</span>
            <span>${(prediction.predictedSales * 52).toLocaleString()} Kƒç</span>
        </div>
    ` : `
        <div class="cost-item">
            <span>üì¶ V√Ωroba donut≈Ø:</span>
            <span>${businessResults.costs.production.toLocaleString()} Kƒç</span>
        </div>
        <div class="cost-item">
            <span>üöö Doprava (${eventData.distance} km √ó 2):</span>
            <span>${businessResults.costs.transport.toLocaleString()} Kƒç</span>
        </div>
        <div class="cost-item">
            <span>üë• Mzdy:</span>
            <span>${businessResults.costs.labor.toLocaleString()} Kƒç</span>
        </div>
        ${businessResults.costs.revenueShare > 0 ? `
        <div class="cost-item">
            <span>üìà Pod√≠l z obratu (5%):</span>
            <span>${businessResults.costs.revenueShare.toLocaleString()} Kƒç</span>
        </div>
        ` : ''}
        <div class="cost-item">
            <span>üè™ N√°jem:</span>
            <span>${businessResults.costs.rent.toLocaleString()} Kƒç</span>
        </div>
        <div class="cost-item">
            <span><strong>Celkov√© n√°klady:</strong></span>
            <span><strong>${businessResults.costs.total.toLocaleString()} Kƒç</strong></span>
        </div>
    `;
    
    // Doporuƒçen√≠
    const recommendations = generateRecommendations(prediction, businessResults, eventData);
    
    resultsDiv.innerHTML = `
        <div class="results-grid">
            <div class="result-item">
                <div class="result-value">${prediction.predictedSales}</div>
                <div class="result-label">üç© Doporuƒçen√© mno≈æstv√≠ donut≈Ø</div>
            </div>
            
            <div class="result-item">
                <div class="result-value">${businessResults.revenue.toLocaleString()}</div>
                <div class="result-label">üí∞ Oƒçek√°van√Ω obrat (Kƒç)</div>
            </div>
            
            <div class="result-item">
                <div class="result-value ${profitClass}">${businessResults.profit.toLocaleString()}</div>
                <div class="result-label">üìä ${eventData.businessModel === 'franchise' ? 'V√°≈° zisk' : 'ƒåist√Ω zisk'} (Kƒç)</div>
            </div>
            
            <div class="result-item">
                <div class="result-value">${prediction.confidence}%</div>
                <div class="result-label">üéØ Spolehlivost predikce</div>
            </div>
            
            <div class="result-item">
                <div class="result-value ${profitClass}">${businessResults.profitMargin.toFixed(1)}%</div>
                <div class="result-label">üìà Mar≈æe</div>
            </div>
            
            <div class="result-item">
                <div class="result-value">${(businessResults.revenue / prediction.predictedSales).toFixed(0)}</div>
                <div class="result-label">üí± Pr≈Ømƒõrn√° cena za donut (Kƒç)</div>
            </div>
        </div>
        
        <div class="costs-breakdown">
            <h4>üí∞ Rozpis n√°klad≈Ø</h4>
            ${costsBreakdown}
        </div>
        
        ${recommendations.length > 0 ? `
        <div style="margin-top: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #2196f3;">
            <h4>üí° Doporuƒçen√≠</h4>
            <ul style="margin: 10px 0 0 20px;">
                ${recommendations.map(rec => `<li>${rec}</li>`).join('')}
            </ul>
        </div>
        ` : ''}
        
        <div style="margin-top: 20px; text-align: center;">
            <button class="btn btn-primary" onclick="savePredictionToSheets()">
                üíæ Ulo≈æit predikci do Google Sheets
            </button>
        </div>
    `;
}

function generateRecommendations(prediction, businessResults, eventData) {
    const recommendations = [];
    
    // Finanƒçn√≠ doporuƒçen√≠
    if (businessResults.profit <= 0) {
        recommendations.push('üö® Z√°porn√Ω zisk! Zvy≈°te cenu donut≈Ø nebo sni≈æte n√°klady');
    } else if (businessResults.profitMargin < 15) {
        recommendations.push('‚ö†Ô∏è N√≠zk√° mar≈æe. Doporuƒçujeme zv√Ω≈°it cenu o 5-10 Kƒç na donut');
    }
    
    // Poƒças√≠ doporuƒçen√≠
    const cacheKey = `${eventData.city}-${eventData.date}`;
    const weather = weatherCache.get(cacheKey);
    if (weather) {
        if (weather.temp > 25) {
            recommendations.push('üå°Ô∏è Vysok√© teploty: P≈ôipravte chlad√≠c√≠ za≈ô√≠zen√≠ pro ƒçokol√°dov√© polevy');
        }
        if (weather.main === 'Rain') {
            recommendations.push('üåßÔ∏è D√©≈°≈• v p≈ôedpovƒõdi: Sni≈æte objedn√°vku o 30-50% a p≈ôipravte kryt√≠');
        }
    }
    
    // Business model doporuƒçen√≠
    if (eventData.businessModel === 'employee' && businessResults.profit < 2000) {
        recommendations.push('üíº Jako zamƒõstnanec: Domluvte si bonus za p≈ôekroƒçen√≠ predikovan√©ho prodeje');
    }
    
    if (eventData.businessModel === 'franchise') {
        recommendations.push('ü§ù Fran≈°√≠za: Zajistƒõte dodr≈æov√°n√≠ brand guidelines a kvality');
    }
    
    // Doprava doporuƒçen√≠
    if (businessResults.costs.transport > businessResults.revenue * 0.15) {
        recommendations.push('üöö Vysok√© dopravn√≠ n√°klady: Zva≈æte v√≠ce akc√≠ v t√©to oblasti nebo sd√≠len√≠ dopravy');
    }
    
    // Mno≈æstv√≠ doporuƒçen√≠
    if (prediction.predictedSales > 500) {
        recommendations.push('üì¶ Velk√° akce: Zajistƒõte dostateƒçn√© skladov√°n√≠ a p≈ô√≠padnƒõ druh√Ω st√°nek');
    }
    
    if (prediction.confidence < 50) {
        recommendations.push('üéØ N√≠zk√° spolehlivost predikce: P≈ôipravte flexibiln√≠ mno≈æstv√≠ a sledujte poƒç√°teƒçn√≠ prodej');
    }
    
    return recommendations;
}

// ===== ANAL√ùZA DAT =====
async function loadAnalysisData() {
    if (historicalData.length === 0) {
        document.getElementById('overallStats').innerHTML = '<p>‚ùå Nejd≈ô√≠ve naƒçtƒõte historick√° data</p>';
        document.getElementById('topEvents').innerHTML = '<p>‚ùå Nejd≈ô√≠ve naƒçtƒõte historick√° data</p>';
        document.getElementById('topCities').innerHTML = '<p>‚ùå Nejd≈ô√≠ve naƒçtƒõte historick√° data</p>';
        return;
    }
    
    // Celkov√© statistiky
    const totalEvents = historicalData.length;
    const totalSales = historicalData.reduce((sum, row) => 
        sum + (parseFloat(row['Skuteƒçn√Ω prodej'] || row['N'] || 0)), 0
    );
    const avgSalesPerEvent = totalSales / totalEvents;
    const totalRevenue = totalSales * CONFIG.DONUT_PRICE;
    
    document.getElementById('overallStats').innerHTML = `
        <div class="results-grid">
            <div class="result-item">
                <div class="result-value">${totalEvents}</div>
                <div class="result-label">üìÖ Celkem akc√≠</div>
            </div>
            <div class="result-item">
                <div class="result-value">${totalSales.toLocaleString()}</div>
                <div class="result-label">üç© Celkem prod√°no</div>
            </div>
            <div class="result-item">
                <div class="result-value">${Math.round(avgSalesPerEvent)}</div>
                <div class="result-label">üìä Pr≈Ømƒõr na akci</div>
            </div>
            <div class="result-item">
                <div class="result-value">${totalRevenue.toLocaleString()}</div>
                <div class="result-label">üí∞ Celkov√Ω obrat (Kƒç)</div>
            </div>
        </div>
    `;
    
    // Nej√∫spƒõ≈°nƒõj≈°√≠ akce
    const topEvents = historicalData
        .map(row => ({
            name: row['N√°zev akce'] || 'Nezn√°m√° akce',
            sales: parseFloat(row['Skuteƒçn√Ω prodej'] || row['N'] || 0),
            rating: parseFloat(row['Hodnocen√≠'] || row['X'] || 0),
            city: row['Mƒõsto'] || row['Lokace'] || 'Nezn√°m√© mƒõsto'
        }))
        .filter(event => event.sales > 0)
        .sort((a, b) => b.sales - a.sales)
        .slice(0, 10);
    
    document.getElementById('topEvents').innerHTML = `
        <div style="max-height: 400px; overflow-y: auto;">
            ${topEvents.map((event, index) => `
                <div style="display: flex; justify-content: space-between; padding: 10px; margin-bottom: 8px; background: ${index < 3 ? '#f8f9fa' : 'white'}; border-radius: 6px; border: 1px solid #e9ecef;">
                    <div>
                        <div style="font-weight: bold;">${index + 1}. ${event.name}</div>
                        <div style="font-size: 0.9em; color: #666;">üìç ${event.city} | ${'‚≠ê'.repeat(Math.max(event.rating, 1))}</div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-weight: bold; color: #28a745;">${event.sales} üç©</div>
                        <div style="font-size: 0.9em; color: #666;">${(event.sales * CONFIG.DONUT_PRICE).toLocaleString()} Kƒç</div>
                    </div>
                </div>
            `).join('')}
        </div>
    `;
    
    // Nejlep≈°√≠ mƒõsta
    const cityStats = {};
    historicalData.forEach(row => {
        const city = row['Mƒõsto'] || row['Lokace'] || 'Nezn√°m√© mƒõsto';
        const sales = parseFloat(row['Skuteƒçn√Ω prodej'] || row['N'] || 0);
        const rating = parseFloat(row['Hodnocen√≠'] || row['X'] || 0);
        
        if (!cityStats[city]) {
            cityStats[city] = { totalSales: 0, events: 0, totalRating: 0 };
        }
        
        cityStats[city].totalSales += sales;
        cityStats[city].events += 1;
        cityStats[city].totalRating += rating;
    });
    
    const topCities = Object.entries(cityStats)
        .map(([city, stats]) => ({
            city,
            avgSales: stats.totalSales / stats.events,
            events: stats.events,
            totalSales: stats.totalSales,
            avgRating: stats.totalRating / stats.events
        }))
        .filter(city => city.events >= 2) // Alespo≈à 2 akce
        .sort((a, b) => b.avgSales - a.avgSales)
        .slice(0, 10);
    
    document.getElementById('topCities').innerHTML = `
        <div style="max-height: 400px; overflow-y: auto;">
            ${topCities.map((city, index) => `
                <div style="display: flex; justify-content: space-between; padding: 10px; margin-bottom: 8px; background: ${index < 3 ? '#f8f9fa' : 'white'}; border-radius: 6px; border: 1px solid #e9ecef;">
                    <div>
                        <div style="font-weight: bold;">${index + 1}. ${city.city}</div>
                        <div style="font-size: 0.9em; color: #666;">${city.events} akc√≠ | ${'‚≠ê'.repeat(Math.max(Math.round(city.avgRating), 1))}</div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-weight: bold; color: #28a745;">${Math.round(city.avgSales)} üç©/akci</div>
                        <div style="font-size: 0.9em; color: #666;">Celkem: ${city.totalSales} üç©</div>
                    </div>
                </div>
            `).join('')}
        </div>
    `;
}

// ===== ULO≈ΩEN√ç PREDIKCE DO SHEETS =====
async function savePredictionToSheets() {
    const eventData = gatherEventData();
    if (!isEventDataComplete(eventData)) {
        showNotification('‚ùå Vypl≈àte v≈°echny √∫daje p≈ôed ulo≈æen√≠m', 'error');
        return;
    }
    
    try {
        showNotification('üíæ Ukl√°d√°m predikci do Google Sheets...', 'info');
        
        // Pro jednoduchost zat√≠m jen simulujeme ulo≈æen√≠
        // V re√°ln√© implementaci by se pou≈æilo Google Sheets API
        
        setTimeout(() => {
            showNotification('‚úÖ Predikce byla √∫spƒõ≈°nƒõ ulo≈æena do Google Sheets!', 'success');
        }, 2000);
        
        console.log('üíæ Predikce k ulo≈æen√≠:', eventData);
        
    } catch (error) {
        console.error('‚ùå Chyba p≈ôi ukl√°d√°n√≠:', error);
        showNotification('‚ùå Chyba p≈ôi ukl√°d√°n√≠ predikce', 'error');
    }
}

// ===== NASTAVEN√ç =====
function saveSettings() {
    const settings = {
        googleSheetsUrl: document.getElementById('googleSheetsUrl').value,
        weatherApiKey: document.getElementById('weatherApiKey').value,
        mapsApiKey: document.getElementById('mapsApiKey').value,
        donutCost: parseFloat(document.getElementById('donutCost').value),
        donutPrice: parseFloat(document.getElementById('donutPrice').value),
        franchisePrice: parseFloat(document.getElementById('franchisePrice').value),
        hourlyWage: parseFloat(document.getElementById('hourlyWage').value)
    };
    
    localStorage.setItem('donulandSettings', JSON.stringify(settings));
    showNotification('‚úÖ Nastaven√≠ byla ulo≈æena', 'success');
    
    console.log('üíæ Nastaven√≠ ulo≈æena:', settings);
}

function loadSettings() {
    const saved = localStorage.getItem('donulandSettings');
    if (saved) {
        try {
            const settings = JSON.parse(saved);
            
            // Aplikace nastaven√≠
            if (settings.googleSheetsUrl) document.getElementById('googleSheetsUrl').value = settings.googleSheetsUrl;
            if (settings.weatherApiKey) document.getElementById('weatherApiKey').value = settings.weatherApiKey;
            if (settings.mapsApiKey) document.getElementById('mapsApiKey').value = settings.mapsApiKey;
            if (settings.donutCost) document.getElementById('donutCost').value = settings.donutCost;
            if (settings.donutPrice) document.getElementById('donutPrice').value = settings.donutPrice;
            if (settings.franchisePrice) document.getElementById('franchisePrice').value = settings.franchisePrice;
            if (settings.hourlyWage) document.getElementById('hourlyWage').value = settings.hourlyWage;
            
            console.log('‚úÖ Nastaven√≠ naƒçtena');
        } catch (error) {
            console.warn('‚ö†Ô∏è Chyba p≈ôi naƒç√≠t√°n√≠ nastaven√≠:', error);
        }
    }
}

async function testConnections() {
    showNotification('üîß Testuji p≈ôipojen√≠...', 'info');
    
    const results = [];
    
    // Test Weather API
    try {
        const weatherKey = document.getElementById('weatherApiKey').value;
        const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=Praha&appid=${weatherKey}`);
        if (response.ok) {
            results.push('‚úÖ Weather API: OK');
        } else {
            results.push('‚ùå Weather API: Chyba');
        }
    } catch (error) {
        results.push('‚ùå Weather API: Chyba p≈ôipojen√≠');
    }
    
    // Test Google Sheets
    try {
        const sheetsUrl = document.getElementById('googleSheetsUrl').value;
        const sheetId = extractSheetId(sheetsUrl);
        if (sheetId) {
            const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;
            const response = await fetch(csvUrl);
            if (response.ok) {
                results.push('‚úÖ Google Sheets: OK');
            } else {
                results.push('‚ùå Google Sheets: Chyba p≈ô√≠stupu');
            }
        } else {
            results.push('‚ùå Google Sheets: Neplatn√© URL');
        }
    } catch (error) {
        results.push('‚ùå Google Sheets: Chyba p≈ôipojen√≠');
    }
    
    showNotification(results.join('\n'), results.every(r => r.includes('‚úÖ')) ? 'success' : 'warning');
}

// ===== UTILITY FUNKCE =====
function setDefaultValues() {
    // Nastaven√≠ z√≠t≈ôej≈°√≠ho data
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    const tomorrowStr = tomorrow.toISOString().split('T')[0];
    
    const dateInput = document.getElementById('eventDate');
    if (dateInput) {
        dateInput.value = tomorrowStr;
        dateInput.min = new Date().toISOString().split('T')[0];
    }
}

function updateStatusIndicator(status, message) {
    const indicator = document.getElementById('statusIndicator');
    if (!indicator) return;
    
    const dot = indicator.querySelector('.status-dot');
    const text = indicator.querySelector('span:last-child');
    
    switch(status) {
        case 'success':
            dot.style.background = '#28a745';
            indicator.style.background = '#d4edda';
            indicator.style.color = '#155724';
            break;
        case 'error':
            dot.style.background = '#dc3545';
            indicator.style.background = '#f8d7da';
            indicator.style.color = '#721c24';
            break;
        default:
            dot.style.background = '#28a745';
            indicator.style.background = '#d4edda';
            indicator.style.color = '#155724';
    }
    
    text.textContent = message || 'Online';
}

function showNotification(message, type = 'info', duration = 5000) {
    // Odebr√°n√≠ existuj√≠c√≠ch notifikac√≠
    document.querySelectorAll('.notification').forEach(n => n.remove());
    
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    
    const icon = type === 'success' ? '‚úÖ' : 
                type === 'error' ? '‚ùå' : 
                type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
    
    notification.innerHTML = `
        <div style="display: flex; align-items: flex-start; gap: 10px;">
            <span style="font-size: 1.2em;">${icon}</span>
            <div style="flex: 1;">
                <div style="font-weight: 600; margin-bottom: 4px;">${type.charAt(0).toUpperCase() + type.slice(1)}</div>
                <div style="white-space: pre-line;">${message}</div>
            </div>
            <span onclick="this.parentElement.parentElement.remove()" style="cursor: pointer; opacity: 0.7;">‚úï</span>
        </div>
    `;
    
    document.body.appendChild(notification);
    
    // Animace zobrazen√≠
    setTimeout(() => notification.classList.add('show'), 100);
    
    // Auto odstranƒõn√≠
    setTimeout(() => {
        if (notification.parentElement) {
            notification.classList.remove('show');
            setTimeout(() => notification.remove(), 300);
        }
    }, duration);
}

// ===== INICIALIZACE =====
console.log('‚úÖ Donuland Management System naƒçten a p≈ôipraven!');
